[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Processing"})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/usuario/Desktop/personal/SCALA/EJERCICIOS/ejercicios/src/main/scala/virtual_wallet/WalletActor.scala","languageId":"scala","version":1,"text":"package main.scala.virtual_wallet\r\n\r\nimport java.util.UUID\r\n\r\nimport akka.actor.{Actor, ActorLogging, ActorRef, Props, Stash}\r\nimport akka.cluster.sharding.ShardRegion.{ExtractEntityId, ExtractShardId}\r\nimport akka.pattern.{ask, pipe}\r\nimport akka.util.Timeout\r\nimport com.fasterxml.jackson.annotation.JsonTypeInfo\r\nimport main.scala.virtual_wallet.Entity._\r\n\r\nimport scala.language.postfixOps\r\nimport scala.concurrent.Future\r\nimport scala.concurrent.duration.DurationInt\r\nimport scala.util.{Failure, Success}\r\n\r\nobject WalletActor {\r\n\r\n  @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, property = \"type\")\r\n  trait SerializableMessage\r\n\r\n  trait Command extends SerializableMessage { val userCuit: String }\r\n  trait Query extends SerializableMessage { val userCuit: String }\r\n  trait Event extends SerializableMessage\r\n  trait Response extends SerializableMessage\r\n\r\n  case class CreateWallet(userCuit: String) extends Command\r\n  case class Recharge(userCuit: String, value: BigDecimal) extends Command\r\n  case class Consume(userCuit: String, value: BigDecimal) extends Command\r\n  case class Transfer(userCuit: String, value: BigDecimal, wallet: Option[ActorRef]) extends Command\r\n  case class UpdateUserData(userCuit: String, user: User) extends Command\r\n\r\n  case class WalletCreated(userCuit: String) extends Event\r\n  case class Recharged(value: BigDecimal) extends Event\r\n  case class Consumed(value: BigDecimal) extends Event\r\n  case class UserDataUpdated(user: User) extends Event\r\n  case class SuccessfulTransfer(value: BigDecimal, user: User, destination: Boolean) extends Event\r\n  case class FailedTransfer(value: BigDecimal, user: User, ex: Exception) extends Event\r\n\r\n  case class WalletBalance(balance: BigDecimal) extends Response\r\n  case class WalletUser(user: User) extends Response\r\n\r\n  case class GetBalance(userCuit: String) extends Query\r\n  case class GetUserInfo(userCuit: String) extends Query\r\n\r\n  case class WalletNotFoundException(walletId: WalletId) extends IllegalStateException(s\"Wallet Not Found: $walletId\")\r\n  case class WalletNotInitializedException() extends IllegalStateException(s\"Wallet with that cuit not initialized\")\r\n  case class WalletNotEnoughBalanceException(walletId: WalletId) extends IllegalStateException(s\"Wallet Not Enough Balance: $walletId\")\r\n  case class FailedTransferException(user: String, ex: Exception) extends IllegalStateException(s\"The transfer to $user failed: ${ex.getMessage}\")\r\n\r\n  def props(): Props = Props(new WalletActor())\r\n\r\n  val entityIdExtractor: ExtractEntityId = {\r\n    case c: Command => (c.userCuit, c)\r\n    case q: Query => (q.userCuit, q)\r\n  }\r\n\r\n  val shardIdExtractor: ExtractShardId = {\r\n    case c: Command => Math.abs(c.userCuit.hashCode % 30).toString\r\n    case q: Query => Math.abs(q.userCuit.hashCode % 30).toString\r\n  }\r\n}\r\n\r\nclass WalletActor extends Actor with ActorLogging with Stash {\r\n  import WalletActor._\r\n  import context.dispatcher\r\n  implicit val timeout: Timeout = Timeout(5 seconds)\r\n\r\n  var walletId: WalletId = WalletId()\r\n  var wallet: Wallet = Wallet()\r\n\r\n  override def receive: Receive = {\r\n    case c: Command =>\r\n      context.become(handleCommand(sender()))\r\n      self ! c\r\n    case q: Query =>\r\n      context.become(handleQuery(sender()))\r\n      self ! q\r\n  }\r\n\r\n  def handleCommand(sender: ActorRef): Receive = {\r\n    case CreateWallet(cuit) =>\r\n      log.info(s\"--- CreateWallet($cuit) ---\")\r\n      walletId = WalletId()\r\n      context.become(handleEvent(sender))\r\n      self ! WalletCreated(cuit)\r\n\r\n    case Recharge(_, value) =>\r\n      log.info(s\"[${walletId.value}] Recharge($value)\")\r\n      context.become(handleEvent(sender))\r\n      self ! Recharged(value)\r\n\r\n    case Consume(_, value) =>\r\n      log.info(s\"[${walletId.value}] Consume($value)\")\r\n      context.become(handleEvent(sender))\r\n      self ! Consumed(value)\r\n\r\n    case UpdateUserData(_, user) =>\r\n      log.info(s\"[${walletId.value}] UpdateUserData($user)\")\r\n      context.become(handleEvent(sender))\r\n      self ! UserDataUpdated(user)\r\n\r\n    case cmd @ Transfer(_, value, _) =>\r\n      log.info(s\"[${walletId.value}] Transfer($value)\")\r\n      context.become(handleTransfer(sender))\r\n      self ! cmd\r\n  }\r\n\r\n  def handleEvent(sender: ActorRef): Receive = {\r\n    case WalletCreated(cuit) =>\r\n      log.info(s\"[${walletId.value}] WalletCreated($cuit)\")\r\n      wallet = Wallet(walletId, User(None, cuit, None, None))\r\n      sender ! wallet\r\n      context.become(receive)\r\n\r\n    case Recharged(value) =>\r\n      log.info(s\"[${walletId.value}] Recharged($value)\")\r\n      if (wallet.isEmpty())\r\n        Future.failed(WalletNotInitializedException()).pipeTo(sender)\r\n      else {\r\n        wallet = wallet += value\r\n        sender ! wallet\r\n      }\r\n      context.become(receive)\r\n\r\n    case Consumed(value) =>\r\n      log.info(s\"[${walletId.value}] Consumed($value)\")\r\n      if (wallet.isEmpty())\r\n        Future.failed(WalletNotInitializedException()).pipeTo(sender)\r\n      else {\r\n        if(wallet.balance - value < 0)\r\n          Future.failed(WalletNotEnoughBalanceException(walletId)).pipeTo(sender)\r\n        else {\r\n          wallet = wallet -= value\r\n          sender ! wallet\r\n        }\r\n      }\r\n      context.become(receive)\r\n\r\n    case UserDataUpdated(user) =>\r\n      log.info(s\"[${walletId.value}] UserDataUpdated($user)\")\r\n      if (wallet.isEmpty())\r\n        Future.failed(WalletNotInitializedException()).pipeTo(sender)\r\n      else {\r\n        wallet = wallet updateUser user\r\n        sender ! wallet\r\n      }\r\n      context.become(receive)\r\n\r\n    case SuccessfulTransfer(value, user, destination) =>\r\n      log.info(s\"[${walletId.value}] SuccessfulTransfer($value, $user, $destination)\")\r\n      if(!destination)\r\n        sender ! SuccessfulTransfer(value, wallet.user, destination)\r\n      context.become(receive)\r\n      unstashAll()\r\n\r\n    case FailedTransfer(value, user, ex) =>\r\n      log.info(s\"[${walletId.value}] FailedTransfer($value, $user, $ex)\")\r\n      Future.failed(ex).pipeTo(sender)\r\n      context.become(receive)\r\n      unstashAll()\r\n\r\n    case _ => stash()\r\n  }\r\n\r\n  def handleQuery(sender: ActorRef): Receive = {\r\n    case GetBalance(_) =>\r\n      log.info(s\"[${walletId.value}] GetBalance()\")\r\n      if (wallet.isEmpty())\r\n        Future.failed(WalletNotInitializedException()).pipeTo(sender)\r\n      else\r\n        sender ! WalletBalance(wallet.balance)\r\n      context.become(receive)\r\n    case GetUserInfo(_) =>\r\n      log.info(s\"[${walletId.value}] GetUserInfo()\")\r\n      if (wallet.isEmpty())\r\n        Future.failed(WalletNotInitializedException()).pipeTo(sender)\r\n      else\r\n        sender ! WalletUser(wallet.user)\r\n      context.become(receive)\r\n  }\r\n\r\n  def handleTransfer(sender: ActorRef): Receive = {\r\n    case Transfer(userCuit, value, actorRef) =>\r\n      log.info(s\" Transferring ... \")\r\n      actorRef match {\r\n        case Some(actor) => { // Billetera inicial\r\n          context.become(handleEvent(sender)) // Queda escuchando eventos\r\n          if((wallet.balance - value) < 0) // si no tiene saldo para transferir\r\n            self ! FailedTransfer(value, wallet.user, WalletNotEnoughBalanceException(walletId)) // falla la transferencia y lo notifica a traves de un evento\r\n          else {\r\n            (actor ? Transfer(userCuit, value, None)) onComplete { // envia la transferencia a la otra billetera\r\n              case Success(event) => { // si tiene exito\r\n                wallet = wallet -= value // descuenta la plata de la billetera\r\n                self ! event // se notifica a si mismo a traves de un evento que  fue un exito\r\n              }\r\n              case Failure(ex: Exception) => // en el caso de que falle se lo notifica a si mismo a traves de un evento\r\n                self ! FailedTransfer(value, wallet.user, ex)\r\n            }\r\n          }\r\n        }\r\n        case None => { // Billetera destino\r\n          if(wallet.isEmpty()) { // si no esta inicializada\r\n            Future.failed(FailedTransferException(wallet.user.cuit, WalletNotInitializedException())).pipeTo(sender) // devuelve un error\r\n            context.become(receive)\r\n            unstashAll()\r\n          } else { // si esta inicializada\r\n            context.become(handleEvent(sender))\r\n            wallet = wallet += value // suma su valor\r\n            sender ! SuccessfulTransfer(value, wallet.user, false) // notifica a la cuenta inicial traves de un mensaje el exito\r\n            self ! SuccessfulTransfer(value, wallet.user, true) // se notificica del exito\r\n          }\r\n        }\r\n      }\r\n    case _ =>\r\n      log.info(s\" Transferring ... \")\r\n      stash()\r\n  }\r\n\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\usuario\Desktop\personal\SCALA\EJERCICIOS\ejercicios\target\scala-2.13\zinc\inc_compile_2.13.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 0 s, completed Jan 20, 2021 9:19:37 AM[0m
[0m[[0m[0mdebug[0m] [0m[0mjsonRpcNotify: JsonRpcNotificationMessage(2.0, build/logMessage, {"type":4,"message":"Done"})[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
